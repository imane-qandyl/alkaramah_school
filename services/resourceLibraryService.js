/**
 * Resource Library Service
 * Enhanced service for managing teacher-created resources
 */

import { storageService } from './storageService';

class ResourceLibraryService {
  constructor() {
    this.LIBRARY_SETTINGS_KEY = 'resource_library_settings';
  }

  /**
   * Get all resources with enhanced metadata
   */
  async getAllResourcesWithMetadata() {
    try {
      const resources = await storageService.getAllResources();
      
      // Add computed metadata
      return resources.map(resource => ({
        ...resource,
        wordCount: this.getWordCount(resource.content),
        readingTime: this.getReadingTime(resource.content),
        complexity: this.getComplexityLevel(resource.content),
        tags: this.extractTags(resource),
        lastAccessed: resource.lastAccessed || resource.createdAt,
      }));
    } catch (error) {
      console.error('Error getting resources with metadata:', error);
      return [];
    }
  }

  /**
   * Get resource statistics for dashboard
   */
  async getLibraryStats() {
    try {
      const resources = await this.getAllResourcesWithMetadata();
      
      const stats = {
        total: resources.length,
        byFormat: this.groupByFormat(resources),
        byAge: this.groupByAge(resources),
        byComplexity: this.groupByComplexity(resources),
        recentlyCreated: this.getRecentlyCreated(resources),
        mostUsed: this.getMostUsed(resources),
        totalWordCount: resources.reduce((sum, r) => sum + (r.wordCount || 0), 0),
        averageReadingTime: this.getAverageReadingTime(resources),
      };
      
      return stats;
    } catch (error) {
      console.error('Error getting library stats:', error);
      return this.getEmptyStats();
    }
  }

  /**
   * Search resources with advanced filtering
   */
  async searchResources(query, filters = {}) {
    try {
      const resources = await this.getAllResourcesWithMetadata();
      
      return resources.filter(resource => {
        // Text search
        const matchesQuery = !query || 
          resource.title?.toLowerCase().includes(query.toLowerCase()) ||
          resource.content?.toLowerCase().includes(query.toLowerCase()) ||
          resource.aetTarget?.toLowerCase().includes(query.toLowerCase()) ||
          resource.tags?.some(tag => tag.toLowerCase().includes(query.toLowerCase()));

        // Format filter
        const matchesFormat = !filters.format || 
          resource.format === filters.format;

        // Age filter
        const matchesAge = !filters.age || 
          resource.studentAge === filters.age;

        // Complexity filter
        const matchesComplexity = !filters.complexity || 
          resource.complexity === filters.complexity;

        // Date range filter
        const matchesDateRange = this.matchesDateRange(resource, filters.dateRange);

        return matchesQuery && matchesFormat && matchesAge && 
               matchesComplexity && matchesDateRange;
      });
    } catch (error) {
      console.error('Error searching resources:', error);
      return [];
    }
  }

  /**
   * Get recommended resources based on usage patterns
   */
  async getRecommendedResources(limit = 5) {
    try {
      const resources = await this.getAllResourcesWithMetadata();
      
      // Simple recommendation based on recent usage and format diversity
      return resources
        .sort((a, b) => {
          const aScore = this.getRecommendationScore(a);
          const bScore = this.getRecommendationScore(b);
          return bScore - aScore;
        })
        .slice(0, limit);
    } catch (error) {
      console.error('Error getting recommended resources:', error);
      return [];
    }
  }

  /**
   * Mark resource as accessed (for usage tracking)
   */
  async markResourceAccessed(resourceId) {
    try {
      await storageService.updateResource(resourceId, {
        lastAccessed: new Date().toISOString(),
        accessCount: await this.incrementAccessCount(resourceId)
      });
    } catch (error) {
      console.error('Error marking resource as accessed:', error);
    }
  }

  /**
   * Duplicate a resource with modifications
   */
  async duplicateResource(resourceId, modifications = {}) {
    try {
      const originalResource = await storageService.getResourceById(resourceId);
      if (!originalResource) {
        throw new Error('Resource not found');
      }

      const duplicatedResource = {
        ...originalResource,
        ...modifications,
        title: modifications.title || `${originalResource.title} (Copy)`,
        id: undefined, // Will be generated by saveResource
        createdAt: new Date().toISOString(),
        lastModified: new Date().toISOString(),
        originalResourceId: resourceId,
      };

      return await storageService.saveResource(duplicatedResource);
    } catch (error) {
      console.error('Error duplicating resource:', error);
      return { success: false, error: error.message };
    }
  }

  // Helper methods
  getWordCount(content) {
    if (!content) return 0;
    return content.trim().split(/\s+/).length;
  }

  getReadingTime(content) {
    const wordCount = this.getWordCount(content);
    const wordsPerMinute = 200; // Average reading speed
    return Math.ceil(wordCount / wordsPerMinute);
  }

  getComplexityLevel(content) {
    if (!content) return 'simple';
    
    const wordCount = this.getWordCount(content);
    const sentences = content.split(/[.!?]+/).length;
    const avgWordsPerSentence = wordCount / sentences;
    
    if (avgWordsPerSentence > 20) return 'complex';
    if (avgWordsPerSentence > 15) return 'moderate';
    return 'simple';
  }

  extractTags(resource) {
    const tags = [];
    
    // Add format as tag
    if (resource.format) tags.push(resource.format);
    
    // Add age as tag
    if (resource.studentAge) tags.push(`age-${resource.studentAge}`);
    
    // Add ability level as tag
    if (resource.abilityLevel) tags.push(resource.abilityLevel);
    
    // Extract keywords from AET target
    if (resource.aetTarget) {
      const keywords = resource.aetTarget.toLowerCase()
        .split(/[,\s]+/)
        .filter(word => word.length > 3);
      tags.push(...keywords);
    }
    
    return [...new Set(tags)]; // Remove duplicates
  }

  groupByFormat(resources) {
    return resources.reduce((acc, resource) => {
      const format = resource.format || 'other';
      acc[format] = (acc[format] || 0) + 1;
      return acc;
    }, {});
  }

  groupByAge(resources) {
    return resources.reduce((acc, resource) => {
      const age = resource.studentAge || 'unknown';
      acc[age] = (acc[age] || 0) + 1;
      return acc;
    }, {});
  }

  groupByComplexity(resources) {
    return resources.reduce((acc, resource) => {
      const complexity = resource.complexity || 'simple';
      acc[complexity] = (acc[complexity] || 0) + 1;
      return acc;
    }, {});
  }

  getRecentlyCreated(resources, days = 7) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - days);
    
    return resources.filter(resource => 
      new Date(resource.createdAt || resource.timestamp) > cutoff
    );
  }

  getMostUsed(resources, limit = 5) {
    return resources
      .sort((a, b) => (b.accessCount || 0) - (a.accessCount || 0))
      .slice(0, limit);
  }

  getAverageReadingTime(resources) {
    if (resources.length === 0) return 0;
    const totalTime = resources.reduce((sum, r) => sum + (r.readingTime || 0), 0);
    return Math.round(totalTime / resources.length);
  }

  getRecommendationScore(resource) {
    let score = 0;
    
    // Recent resources get higher score
    const daysSinceCreated = (new Date() - new Date(resource.createdAt || resource.timestamp)) / (1000 * 60 * 60 * 24);
    if (daysSinceCreated < 7) score += 10;
    else if (daysSinceCreated < 30) score += 5;
    
    // Frequently accessed resources get higher score
    score += (resource.accessCount || 0) * 2;
    
    // Moderate complexity gets higher score (not too simple, not too complex)
    if (resource.complexity === 'moderate') score += 3;
    
    return score;
  }

  matchesDateRange(resource, dateRange) {
    if (!dateRange) return true;
    
    const resourceDate = new Date(resource.createdAt || resource.timestamp);
    const { start, end } = dateRange;
    
    if (start && resourceDate < new Date(start)) return false;
    if (end && resourceDate > new Date(end)) return false;
    
    return true;
  }

  async incrementAccessCount(resourceId) {
    try {
      const resource = await storageService.getResourceById(resourceId);
      return (resource?.accessCount || 0) + 1;
    } catch (error) {
      return 1;
    }
  }

  getEmptyStats() {
    return {
      total: 0,
      byFormat: {},
      byAge: {},
      byComplexity: {},
      recentlyCreated: [],
      mostUsed: [],
      totalWordCount: 0,
      averageReadingTime: 0,
    };
  }
}

export const resourceLibraryService = new ResourceLibraryService();